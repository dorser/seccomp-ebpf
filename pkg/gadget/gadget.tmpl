#include <vmlinux.h>

#include <bpf/bpf_core_read.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

#include <gadget/buffer.h>
#include <gadget/macros.h>
#include <gadget/mntns_filter.h>
#include <gadget/types.h>

#ifndef TASK_COMM_LEN
#define TASK_COMM_LEN 16
#endif

static const bool false_value = false;

struct {
	__uint(type, BPF_MAP_TYPE_HASH);
	__uint(max_entries, 10240);
	__type(key, u64);
	__type(value, bool);
} block_actions SEC(".maps");


{{range $syscall := .Syscalls}}
SEC("tracepoint/syscalls/sys_enter_{{$syscall.Name}}")
int tracepoint__sys_enter_{{$syscall.Name}}(struct trace_event_raw_sys_enter *ctx) {
  {{- range $arg := $syscall.Args -}}
  {{if ne $arg.Args.Op ""}}
  {{if eq $arg.Args.Op "&"}}
  if (({{$arg.Args.Value}} {{$arg.Args.Op}} ctx->args[{{$arg.Args.Index}}]) == {{$arg.Args.ValueTwo}}) 
  {{else}}
  if (ctx->args[{{$arg.Args.Index}}] {{$arg.Args.Op}} {{$arg.Args.Value}}) 
  {{end}}
  {
    {{if eq $arg.Action "SCMP_ACT_ALLOW"}}
    return 0;
    {{end}}
  }
  {{end}}
  {{end}}

    {{if ne $syscall.Action "SCMP_ACT_ALLOW"}}
    {{if eq $syscall.Action "SCMP_ACT_ERRNO"}}
	  u64 pid_tgid = bpf_get_current_pid_tgid();
	  bpf_map_update_elem(&block_actions, &pid_tgid, &false_value, BPF_NOEXIST);

    {{else}}
    {{$syscall.Action}}
    {{end}}
	{{end}}
    return 0;


}
{{end}}

char LICENSE[] SEC("license") = "GPL";		

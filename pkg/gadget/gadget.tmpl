#include <vmlinux.h>

#include <bpf/bpf_core_read.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

#include <gadget/buffer.h>
#include <gadget/macros.h>
#include <gadget/mntns_filter.h>
#include <gadget/types.h>

const uint SCMP_ACT_KILL = 1;
const uint SCMP_ACT_KILL_PROCESS = 2;
const uint SCMP_ACT_KILL_THREAD = 3;
const uint SCMP_ACT_TRAP = 4;
const uint SCMP_ACT_ERRNO = 5;
const uint SCMP_ACT_TRACE = 6;
const uint SCMP_ACT_ALLOW = 7;
const uint SCMP_ACT_LOG = 8;
const uint SCMP_ACT_NOTIFY = 9;

struct event {
  gadget_syscall syscall_raw;
  uint action;
};

GADGET_TRACER_MAP(events, 1024 * 256);
GADGET_TRACER(event_actions, events, event);

struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240);
  __type(key, u64);
  __type(value, uint);
} actions SEC(".maps");

SEC("raw_tracepoint/sys_enter")
int tracepoint__sys_enter(struct bpf_raw_tracepoint_args *ctx) {
    struct event *event;
  __u64 pid_tgid = bpf_get_current_pid_tgid();

  __u64 mntns_id = gadget_get_mntns_id();
  if (gadget_should_discard_mntns_id(mntns_id))
    return 0;

  uint *action = bpf_map_lookup_elem(&actions, &pid_tgid);
  if (!action) {
    action = &{{ .DefaultAction }};
  }
  
  event = gadget_reserve_buf(&events, sizeof(*event));
  if (!event)
    return 0;
  event->syscall_raw = ctx->args[1];
  event->action = *action;
  gadget_submit_buf(ctx, &events, event, sizeof(*event));

  return 0;
}
{{ range $syscallName, $syscall  := .Syscalls }}
SEC("tracepoint/syscalls/sys_enter_{{ $syscallName }}")
int tracepoint__sys_enter_{{ $syscallName }}(struct trace_event_raw_sys_enter *ctx) 
{
  u64 mntns_id = gadget_get_mntns_id();
  if (gadget_should_discard_mntns_id(mntns_id))
    return 0;
  u64 pid_tgid = bpf_get_current_pid_tgid();
  {{ range $idx := $syscall.ArgsIndices }}
  {{- /* The operands for Seccomp conditions are uint64: https://github.com/seccomp/libseccomp-golang/blob/main/seccomp.go#L66 */}}
  u64 arg{{ $idx }} = ctx->args[{{ $idx }}];
  {{ end }}
  {{- range $rule := $syscall.Rules }}
  {{- /* TODO: iterate over args. For now we assume it is an array with a single element */}}
  {{ if $rule.Args -}}
  {{ if eq (index $rule.Args 0).Op "&" }}
  if (({{ (index $rule.Args 0).Value }} {{ (index $rule.Args 0).Op }} arg{{ (index $rule.Args 0).Index }}) == {{ (index $rule.Args 0).ValueTwo }}) 
  {{ else }}
  if (arg{{ (index $rule.Args 0).Index }} {{ (index $rule.Args 0).Op }} {{ (index $rule.Args 0).Value }}) 
  {{ end -}}
  {
  {{ end -}}
  bpf_map_update_elem(&actions, &pid_tgid, &{{ $rule.Action }}, BPF_NOEXIST);
  {{- if $rule.Args }}
  }

  {{- end -}}
  {{- end }}
  
  return 0;
}
{{ end }}
char LICENSE[] SEC("license") = "GPL";

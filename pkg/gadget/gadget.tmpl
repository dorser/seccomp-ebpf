#include <vmlinux.h>

#include <bpf/bpf_core_read.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

#include <gadget/buffer.h>
#include <gadget/macros.h>
#include <gadget/mntns_filter.h>
#include <gadget/types.h>

const uint SCMP_ACT_KILL = 1;
const uint SCMP_ACT_KILL_PROCESS = 2;
const uint SCMP_ACT_KILL_THREAD = 3;
const uint SCMP_ACT_TRAP = 4;
const uint SCMP_ACT_ERRNO = 5;
const uint SCMP_ACT_TRACE = 6;
const uint SCMP_ACT_ALLOW = 7;
const uint SCMP_ACT_LOG = 8;
const uint SCMP_ACT_NOTIFY = 9;

struct event {
  gadget_syscall syscall_raw;
  uint action;
};

GADGET_TRACER_MAP(events, 1024 * 256);
GADGET_TRACER(event_actions, events, event);

struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240);
  __type(key, u64);
  __type(value, uint);
} actions SEC(".maps");

SEC("raw_tracepoint/sys_enter")
int tracepoint__sys_enter(struct bpf_raw_tracepoint_args *ctx) {
    struct event *event;
  __u64 pid_tgid = bpf_get_current_pid_tgid();

  __u64 mntns_id = gadget_get_mntns_id();
  if (gadget_should_discard_mntns_id(mntns_id))
    return 0;

  uint *action = bpf_map_lookup_elem(&actions, &pid_tgid);
  if (!action) {
    action = &{{ .DefaultAction }};
  }
  
  event = gadget_reserve_buf(&events, sizeof(*event));
  if (!event)
    return 0;
  event->syscall_raw = ctx->args[1];
  event->action = *action;
  gadget_submit_buf(ctx, &events, event, sizeof(*event));

  return 0;
}


{{ range $syscallName, $syscall  := .Syscalls }}
SEC("tracepoint/syscalls/sys_enter_{{ $syscallName }}")
int tracepoint__sys_enter_{{ $syscallName }}(struct trace_event_raw_sys_enter *ctx) 
{
  u64 mntns_id = gadget_get_mntns_id();
  if (gadget_should_discard_mntns_id(mntns_id))
    return 0;

  u64 pid_tgid = bpf_get_current_pid_tgid();
  bpf_map_update_elem(&actions, &pid_tgid, &{{ (index $syscall 0).Action }}, BPF_NOEXIST);

  return 0;
}
{{ end }}

char LICENSE[] SEC("license") = "GPL";

package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"text/template"
)

// Template for the generated Go file
const templateContent = `// Code generated by generator; DO NOT EDIT. See: github.com/dorser/seccomp-ebpf/tools/syscalls

package syscalls

func SyscallExists(syscall string) bool {
	_, exists := syscalls[syscall]
	return exists
}

var syscalls = map[string]struct{}{
	{{- range $syscallName, $tracepoints := . }}
	"{{ $syscallName }}": {},
	{{- end }}
}
`

// syscallTable holds the available syscalls
var syscallTable = make(map[string]struct{})

// populateSyscallTable executes the ausyscall --dump command and populates the syscallTable.
func populateSyscallTable() error {
	// Execute the ausyscall command
	cmd := exec.Command("ausyscall", "--dump")
	var out bytes.Buffer
	cmd.Stdout = &out

	err := cmd.Run()
	if err != nil {
		return fmt.Errorf("failed to run ausyscall: %v, output: %s", err, out.String())
	}

	// Split the output into lines and populate the syscallTable
	lines := strings.Split(out.String(), "\n")
	for _, line := range lines[1:] {
		parts := strings.Fields(line)
		if len(parts) > 1 {
			syscallName := parts[1]                // The second element is the syscall name
			syscallTable[syscallName] = struct{}{} // Use struct{} for space efficiency
		}
	}
	return nil
}

func main() {
	outputFile := flag.String("output", "syscalls_generated.go", "Name of the output file")
	flag.Parse()

	// Populate the syscall table
	if err := populateSyscallTable(); err != nil {
		fmt.Printf("Error populating syscall table: %v\n", err)
		return
	}

	// Prepare the template
	tmpl, err := template.New("syscallTracepoints").Parse(templateContent)
	if err != nil {
		fmt.Printf("Failed to parse template: %v\n", err)
		return
	}

	// Create the output file
	output, err := os.Create(*outputFile)
	if err != nil {
		fmt.Printf("Failed to create %s: %v\n", *outputFile, err)
		return
	}
	defer output.Close()

	// Execute the template with the syscall data
	err = tmpl.Execute(output, syscallTable)
	if err != nil {
		fmt.Printf("Failed to execute template: %v\n", err)
		return
	}

	fmt.Printf("Generated file %s successfully.\n", *outputFile)
}
